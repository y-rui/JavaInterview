### java内存泄漏和内存溢出

#### 1.概念

1. 内存泄露：被分配对象可达但无用
2. 内存溢出：无法申请到足够的内存而产生的错误

#### 2.内存泄漏场景

1. 创建和应用生命周期一样的单例对象
2. 创建匿名内部类的静态对象
3. 未关闭资源
4. 长时间存在的集合容器中创建生命周期短的对象
5. 修改hashset中的值，因此改变了该对象的哈希值

```java
示例：A a = new A();
     B b = new B(a);
     a = null;  //期望a被回收，但事实是b中还有a的引用，所以导致a内存地址不可用，导致泄漏。可以使用弱引用（当a失效时，所有的引用也失效）解决。
```

#### 3.内存溢出场景

1. 堆内存溢出
2. 方法区内存溢出（反射，静态变量）
3. 线程栈溢出（递归）

#### 4.分析内存溢出（mat分析内存工具）

- 通过参数 -XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现溢出时Dump出当前的内存堆转储快照以便事后进行分析。如果时采用的eclispse开发工具，自带一个内存影像分析工具对dump 出来的堆转储快照进行分析，重点时分析到底时出现了内存泄漏（Memory Leak）还是 内存溢出（Memeory OverFlow）.
- 如果出现的内存泄露问题，进一步通过工具查看泄露对象到GC Roots 的引用连。找到泄露对象时通过怎么样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收他们的，掌握了泄露对象的类型信息以及GCRoots 引用连的信息，就可以比较准确的定位出泄露代码的位置。
- 如果不存在泄露，换句话说就是 内存中的对象确实都必须存活着，那就检查虚拟机的堆参数，与机器物理内存对比看是否好可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。

#### 5.避免内存溢出

1. 尽早释放无用内存
2. 处理字符串尽可能使用StringBuffer，因为每创建一个String占一个独立内存
3. 少用静态变量（JDK1.8不存在方法区，不用考虑）
4. 避免循环中创建对象