### 简述 BIO, NIO, AIO 的区别

#### 先验知识

**同步**：java自己处理io读写
**异步**：java把io操作委托给os处理，且要把数据缓冲区大小和地址传给os,os要支持异步io操作的api.

**阻塞**：java调用会一直阻塞直到读写完成。
**非阻塞**：如果不能进行读写，java调用会立即返回，当io事件分发器通知可读写时再继续进行io读写，一直循环直到读写完成。

#### Bio、Nio和Aio三者比较

| 名称 | 说明         | 应用场景                                                     | 补充                                   | 优点                 | 缺点                               |
| ---- | ------------ | ------------------------------------------------------------ | -------------------------------------- | -------------------- | ---------------------------------- |
| Bio  | 阻塞io       | Apache，Tomcat。主要是并发量要求不高的场景                   | 连接数目比较小且固定的架构             | 模型简单、编码简单、 | 性能瓶颈低、不适合高并发           |
| Nio  | 同步非阻塞io | Nginx，Netty。主要是高并发量要求的场景                       | 连接数目多且连接比较短（轻操作）的架构 | 性能瓶颈高           | 模型复杂、编码复杂、需处理半包问题 |
| Aio  | 异步非阻塞io | 还不是特别成熟，底层也基本是多线程模拟，所以应用场景不多，Netty曾经用了，但又放弃了。 | 连接数目多且连接比较长（重操作）的架构 |                      |                                    |

假设有这么一个场景，有一排水壶（客户）在烧水。

AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。

NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。

BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。

可以看出AIO是最聪明省力，NIO相对省力，叫一个人就能看所有的壶，BIO最愚蠢，劳动力低下。

#### 进程中的IO调用步骤

1. 进程向操作系统请求数据 ;
2. 操作系统把外部数据加载到内核的缓冲区中; 
3. 操作系统把内核的缓冲区拷贝到进程的缓冲区 ;
4. 进程获得数据完成自己的功能 ;

当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO，也就是AIO 。

#### Nio与Aio的区别

AIO是发出IO请求后，由操作系统自己去获取IO权限并进行IO操作；NIO则是发出IO请求后，由线程不断尝试获取IO权限，获取到后通知应用程序自己进行IO操作。

AIO只是帮助你从内核中将数据复制到用户空间中，并调用你传入的回调方法。 
NIO 是需要程序自己从内核中将数据复制到用户空间中，并需要程序自己调用相应的处理逻辑。