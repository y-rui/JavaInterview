### synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？

#### 底层实现

- synchronized映射成字节码指令就是增加两个指令：monitorenter， monitorexit

当一条线程执行时遇到monitorenter指令时，它会尝试去获得锁，如果获得锁，那么所计数器+1（为什么要加1，因为它是可重入锁，可根据这个琐计数器判断锁状态），如果没有获得锁，那么阻塞，当它遇到一个monitoerexit时，琐计数器会-1，当计数器为0时，就释放锁（tips：节码中出现的两个monitoerexit指令的原因是：一个正常执行-1，令一个异常时执行，这两个用goto的方式只执行一个）

- lock底层则基于volatile和CAS实现

#### synchronized缺点

synchronized释放锁只有两种情况：

1. 获取锁的线程执行完了该代码块，然后线程释放对锁的占有
2. 线程执行发生异常，此时JVM会让线程自动释放锁

例：

1. 如果这个获取锁的线程由于要等待IO或者其他原因（比如调用了sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能等待。因此，就需要有一种机制可以不让等待的线程一直无期限的等待下去（比如只等待一定时间或者能够响应中断），通过lock就可以办到
2. 当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和写操作不会发生冲突现象。但是synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，当一个线程进行读操作，其他线程只能等待无法进行读操作

- 因此，就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过lock就可以办到。另外，通过lock可以知道线程有没有成功获取到锁，这个是synchronized无法办到的。总的来说lock提供了比synchronized更多的功能

#### lock和synchronized的区别

1. 采用synchronized不需要用户手动的去释放锁，当synchronized方法或者代码块执行完毕之后，系统会自动的让线程释放对锁的占有，而lock则必须要用户去手动释放锁，如果没有主动的释放就可能会导致出现死锁的现象。synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象的发生，而lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，因此使用lock()时需要在finally块中释放锁
2. lock可以让等待锁的线程响应中断（AB线程同时获取锁，A得到后，B进行等待，则B会被Thread.interrupt()方法中断并可去执行其他的代码逻辑），而synchronized无法被中断
3. synchronized是非公平锁（不能保证等待锁线程的顺序），lock实现ReentrantLock可通过实例化True or False的构造参数实现公平锁和非公平锁，默认为非公平锁
4. synchronized无法判断是否获取锁的状态，lock可以判断是否获取到锁
5. lock锁适合代码大量的同步问题，synchronized锁适合代码少量的同步问题
6. 都是可重入锁（在执行对象中所有的同步方法不用再次获得锁）
7. synchronized是一个悲观锁，lock是一个乐观锁

